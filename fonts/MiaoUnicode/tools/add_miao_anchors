#!/usr/bin/env python
'''Add Miao script anchors'''
__copyright__ = 'Copyright (c) 2017 SIL International (http://www.sil.org)'
__license__ = 'Released under the MIT License (http://opensource.org/licenses/MIT)'
__author__ = 'Martin Hosken'

from silfont.core import execute
from collections import namedtuple
from silfont.ufo import Uglif, Uoutline, Ucomponent, Uadvance

argspec = [
    ('ifont',{'help': 'Input UFO'}, {'type': 'infont'}),
    ('ofont',{'help': 'Output UFO','nargs': '?' }, {'type': 'outfont'}),
    ('-l','--log',{'help': 'Log file'}, {'type': 'outfile', 'def': '_anc.log'}),
    ('-a','--analysis',{'help': 'Analysis only; no output font generated', 'action': 'store_true'},{}),
    ('--vspace',{'help': 'Vertical gap between consonant and vowel', 'type':int, 'default':20},{}),
    ('--outhang',{'help': 'Overhang long above/below vowels', 'type':int, 'default':50},{})
    ]

BBox = namedtuple('BBox', ['xmin', 'ymin', 'xmax', 'ymax'])

def getuni(g):
    if 'unicode' in g._contents and len(g['unicode']):
        return int(g['unicode'][0].hex, 16)
    else:
        return 0

def getbbox(g):
    res = (65536, 65536, -65536, -65536)
    for c in g['outline'].contours:
        for p in c['point']:
            if 'type' in p.attrib:      # any actual point counts
                x = float(p.get('x', '0'))
                y = float(p.get('y', '0'))
                res = (min(x, res[0]), min(y, res[1]), max(x, res[2]), max(y, res[3]))
    return BBox(*res)

def glyph_addanchors(g, anchors):
    for n, a in anchors.items():
        g.add('anchor', {'name': n, 'x': str(a[0]), 'y': str(a[1])})

def glyph_removeanchors(g):
    del g._contents['anchor']

def glyph_makecopyref(g, name):
    ng = Uglif(layer=g.layer, name=name)
    ng.add('advance', g['advance'].element.attrib)
    ng.add('outline')
    ng['outline'].appendobject({"base": g.name},'component')
    if name in g.layer:
        logger.log(name + " already in font, so not added", "E")
    else:
        g.layer.addGlyph(ng)
    return ng

def doit(args) :
    infont = args.ifont
    logger = infont.logger
    glyphcount = 0

    vowelglyph = infont.deflayer['miao_i']
    vgbbox = getbbox(vowelglyph)
    newglyphs = []
    for gname in infont.deflayer.keys():
        glyph = infont.deflayer[gname]
        u = getuni(glyph)
        if u in range(0x16F00, 0x16F45):
            add_consonantanchors(glyph, vgbbox.ymax, args)
        elif u in range(0x16F54, 0x16F7C):
            newglyphs.append(add_vowelanchors(glyph, args))
    if args.analysis:
        return
    return infont

def add_consonantanchors(g, vheight, args):
    bb = getbbox(g)
    adv = int(g['advance'].width)
    glyph_removeanchors(g)
    anchors = {
        'W': (adv, bb.ymax/2),
        'S': (adv, bb.ymax),
        'V': (adv, 0),
        'H3': (-args.outhang, bb.ymax + args.vspace),
        'H': ((bb.xmin + bb.xmax) / 2, bb.ymax + args.vspace),
        'F3': (-args.outhang, bb.ymin - args.vspace),
        'F': ((bb.xmin + bb.xmax) / 2, bb.ymin - args.vspace),
        'WH' : (adv, (bb.ymax - vheight) / 2),
        'WL' : (adv, (bb.ymax + vheight) / 2)
#        'WH' : (adv, bb.ymax * 2 / 3 - vheight / 6),
#        'WL' : (adv, bb.ymax / 3 + vheight / 6)
    }
    glyph_addanchors(g, anchors)

def add_vowelanchors(g, args):
    glyph_removeanchors(g)
    ng = glyph_makecopyref(g, g.name+".mark")
    bb = getbbox(g)
    adv = int(g['advance'].width)

    anchors = {
        '_W': (0, bb.ymax / 2),
        '_S': (0, bb.ymax),
        '_V': (0, 0),
        'W': (adv, bb.ymax / 2),
        'S': (adv, bb.ymax), 
        'V': (adv, 0)
    }
    glyph_addanchors(g, anchors)

    anchors = {
        '_HL': (0, 0),
        '_HM': ((bb.xmin + bb.xmax)/2, 0),
        '_HR': (adv, 0),
        '_FL': (0, bb.ymax),
        '_FM': ((bb.xmin + bb.xmax)/2, bb.ymax),
        '_FR': (adv, bb.ymax)
    }
    glyph_addanchors(ng, anchors)
        
    return ng

def cmd() : execute("UFO", doit, argspec) 
if __name__ == "__main__": cmd()
