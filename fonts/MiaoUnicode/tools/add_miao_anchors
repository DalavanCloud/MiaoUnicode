#!/usr/bin/env python
'''Add Miao script anchors'''
__copyright__ = 'Copyright (c) 2017 SIL International (http://www.sil.org)'
__license__ = 'Released under the MIT License (http://opensource.org/licenses/MIT)'
__author__ = 'Martin Hosken'

from silfont.core import execute
from collections import namedtuple
from silfont.ufo import Uglif, Uoutline, Ucomponent, Uadvance

argspec = [
    ('ifont',{'help': 'Input UFO'}, {'type': 'infont'}),
    ('ofont',{'help': 'Output UFO','nargs': '?' }, {'type': 'outfont'}),
    ('-l','--log',{'help': 'Log file'}, {'type': 'outfile', 'def': '_anc.log'}),
    ('-a','--analysis',{'help': 'Analysis only; no output font generated', 'action': 'store_true'},{}),
    # 'choices' for -r should correspond to infont.logger.loglevels.keys()
    ('-r','--report',{'help': 'Set reporting level for log', 'type':str, 'choices':['X','S','E','P','W','I','V']},{}),
    ('--vspace',{'help': 'Vertical gap between consonant and vowel', 'type':int, 'default':20},{}),
    ('--outhang',{'help': 'Overhang long above/below vowels', 'type':int, 'default':50},{})
    ]

BBox = namedtuple('BBox', ['xmin', 'ymin', 'xmax', 'ymax'])

def getuni(g):
    if 'unicode' in g._contents and len(g['unicode']):
        return int(g['unicode'][0].hex, 16)
    else:
        return 0

def getbbox(g):
    res = (65536, 65536, -65536, -65536)
    for c in g['outline'].contours:
        for p in c['points']:
            if 'type' in p.attrib:      # any actual point counts
                x = int(p.get('x', '0'))
                y = int(p.get('y', '0'))
                res = (min(x, res[0]), min(y, res[1]), max(x, res[2]), max(y, res[3]))
    return BBox(*res)

def glyph_addanchors(g, anchors):
    for n, a in anchors.items():
        g.add('anchor', {'name': n, 'x': str(a[0]), 'y': str(a[1])})

def glyph_removeanchors(g):
    del g._contents['anchor']

def doit(args) :
    infont = args.ifont
    if args.report: infont.logger.loglevel = args.report
    glyphcount = 0

#    newglyphs = {}
    for gname, glyph in infont.deflayer.items():
        u = getuni(glyph)
        if u in range(0x16F00, 0x16F45):
            add_consonantanchors(glyph, args)
        elif u in range(0x16F54, 0x16F7C):
            ng = add_vowelanchors(glyph, args, infont)
#            newglyphs[ng.name] = ng
#    infont.deflayer.update(newglyphs)
    if args.analysis:
        return
    return infont

def add_consonantanchors(g, args):
    bb = getbbox(g)
    adv = int(g['advance'].width)
    glyph_removeanchors(g)
    anchors = {
        'W': (adv, bb.ymax/2),
        'S': (adv, bb.ymax),
        'V': (adv, 0),
        'H3': (-args.outhang, bb.ymax + args.vspace),
        'H': ((bb.xmin + bb.xmax) / 2, bb.ymax + args.vspace),
        'F3': (-args.outhang, bb.ymin - args.vspace),
        'F': ((bb.xmin + bb.xmax) / 2, bb.ymin - args.vspace),
        'WH' : (adv, bb.ymax * 2 / 3),
        'WL' : (adv, bb.ymax / 3)
    }
    glyph_addanchors(g, anchors)

def add_vowelanchors(g, args, infont):
    glyph_removeanchors(g)
    ng = Uglif(layer=infont.deflayer, name=g.name+".mark")
    ng['advance'] = Uadvance(ng, g['advance'].element)  # what about g.advance.glif?
    #ng['outline'] = Uoutline(ng, [])
    ng.add('outline')
    ng['outline'].components.append(Ucomponent(ng['outline'], []))
    ng['outline'].components[0].base = g.name
    infont.deflayer.addGlyph(ng)

    bb = getbbox(g)
    adv = int(g['advance'].width)

    anchors = {
        '_W': (0, bb.ymax / 2),
        '_S': (0, bb.ymax),
        '_V': (0, 0),
        'W': (adv, bb.ymax / 2),
        'S': (adv, bb.ymax), 
        'V': (adv, 0)
    }
    glyph_addanchors(g, anchors)

    anchors = {
        '_HL': (0, 0),
        '_HM': ((bb.xmin + bb.xmax)/2, 0),
        '_HR': (adv, 0),
        '_FL': (0, bb.ymax),
        '_FM': ((bb.xmin + bb.xmax)/2, bb.ymax),
        '_FR': (adv, bb.ymax)
    }
    glyph_addanchors(ng, anchors)
        
    return ng

def cmd() : execute("UFO", doit, argspec) 
if __name__ == "__main__": cmd()
